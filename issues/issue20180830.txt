1. 버튼을 누르는 행위는 실시간 반영해서 플레이어가 저장하고 있어야함(OnMoveButtonEvent);
2. 그러나 그 버튼 입력을 통해 '다음 이동 지점'을 정하는 행동은 일정 프레임 당 한번씩 일어나야 함.
3. 버튼입력->바로갱신
   일정 프레임 간격동안 이동->현재 버튼입력상태 확인->이동지점 갱신->다시 일정 프레임 간격동안 이동
	위를 반복

버튼1을누름->떼지않고 버튼2를누름->버튼1을뗌->그러면 버튼2로 이동하고있던게 멈춤
멈춰야 하는 상황 -> 현재 어떤 버튼도 누르고 있지않음.
이동해야 하는 상황 -> 현재 어떤 버튼을 누르고 있을 때, 마지막으로 누른 버튼의 이동을 따라가야 함.
		-> 스택? 그러나 떼는 순서와 누르는 순서는 상관없다. 어차피 4개라 스택으로 짜도 별문제는 없겠지만 별 도움이 안된다.

4개 원소 배열
상 하 좌 우 의 누른 순서를 나타냄
처음엔 모두 0
눌러지면 counter가 1 증가하고, 그 값을 눌러진 버튼에 저장함.
떼지면 counter가 1 감소하고, 그 값보다 큰 값을 가진 모든 값에서 1을 뺌.
이동할때는 counter와 동일한 값을 가진 방향으로 이동함. 물론 counter가 0일 때를 제외.

코루틴: yield 시점에서 유니티에게 제어권을 돌려주며 결과가 마쳐지지 않은 '중간 값'을 리턴
	>yield return: 유니티에게 제어권을 돌려주고, 다음 프레임에서 다시 시작할 수 있는 지점

MoveCheck의 시작 시점은 맨 처음 버튼을 눌렀을 때
버튼을 완전히 뗏을 때는 MoveCheck를 하지 말아야함.
->그럼 버튼을 완전히 뗏을 때 flag를 넣어서 멈추게 하면?
->->뗀후 다시눌렀을 때는 다시 시작이 되어야함. 근데 그게 0.5초가 지나기 전에 이루어졌다면?
적어도 뗀 후, 그 이동이 끝나기 전까지는 새로운 입력에 대한 움직임이 없어야 함.
그냥 코루틴으로, 눌러지면 실행, 떼지면 break하면 될듯?

이동을 0.5초간 하고, 방향은 그냥 알아서 실시간으로 바뀌도록 하면 되는거 아님?

1. 버튼으로 누르는 방향은 실시간으로 적용한다.(Button함수들)
2. 그 실시간으로 적용되는 방향을 0.5초마다 확인해서 다음 '턴'에 어디 갈지를정한다(MoveCheck함수)
3. 그 '턴'동안 Update내에서 사용되는 함수가 실제 이동을 실행한다.(만들어야함 Move함수같은거)

모든 버튼을 뗀 후, 0.5초 내에 다른 버튼을 누르면, 새로운 코루틴이 생성되어버린다. 그래서 기존 코루틴이 안꺼지고 2개의 코루틴이 돌아가게 될것이다
(ifcheckmove가 true니까 안꺼진다.)
이전 코루틴만 플래그로 꺼버린다? 그렇다기보다 코루틴이 돌고 있을때는 다른 코루틴을 생성못하게 하는게 맞다.
왜냐면 이전 코루틴을 바로 꺼버리면 한 '턴'에서 움직이는 중간에 다른 방향으로 도는게 가능하기 때문이다.
코루틴의 실행중일 때는 다른 코루틴을 실행 못하게 하는 것이 답

MoveToward의 delta는 움직이는 단위, 이 단위만큼 못움직이면 당연히 못움직이고, 이 단위보다 짧은 거리에 target이있으면 그냥 target으로 가고 끝이라는 이야기

현재 벽에 박으면 코루틴이 끝나는데 ifMoveCheck는 true인 문제가 있음.